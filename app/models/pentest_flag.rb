class PentestFlag < Flag
  belongs_to :team, inverse_of: :flags
  belongs_to :challenge, inverse_of: :flags, foreign_key: 'challenge_id', class_name: 'PentestChallenge'

  has_many :solved_challenges, inverse_of: :flag, foreign_key: 'flag_id', class_name: 'PentestSolvedChallenge', dependent: :destroy

  has_many :submitted_flags, inverse_of: :flag, foreign_key: 'flag_id', class_name: 'PentestSubmittedFlag', dependent: :destroy

  attr_accessor :submitted_flag

  enum challenge_state: { inherit_parent_state: 0, force_closed: 1 }

  def get_solved_challenge_for(team)
    solved_challenges.find_by(team: team)
  end

  def name
    challenge.name
  end

  def description
    challenge.description
  end

  def point_value
    123
  end

  def solved?
    solved_challenges&.count&.positive?
  end

  def force_closed?
    super || challenge.force_closed?
  end

  def challenge_open?
    !force_closed? && challenge.challenge_open?
  end

  def open?
    !force_closed? && challenge.open?
  end

  def find_flag(flag_str)
    return self if flag_str == flag
  end

  def start_calculation_at
    super || Game.instance.start
  end

  # Takes an ordered list of solved challenges and calculates how many points each team should get for solving
  # a specific teams flag
  def calc_points_for_solved_challenges
    # Calculate defensive points for teams which still haven't had their challenges solved
    return { team => challenge.calc_defensive_points(start_calculation_at, Game.instance.defense_end) } if solved_challenges.empty?

    first_solve = solved_challenges.first
    # Calculate bonus points that teams receive for solving a challenge. This also calculates defensive points for
    # a team before their challenge was solved.
    team_points = calc_bonus_points_for(team, start_calculation_at, first_solve)
    # Return the bonus points and offensive points hashes merged into 1.
    team_points.merge_and_sum(calculate_offensive_points_for_solved_challenges(first_solve))
  end

  # Bonus points are offensive and defensive points awarded, either for defending for a period of time or
  # successfully being the first to break into a challenge
  def calc_bonus_points_for(team, start_time, first_solve)
    {
      # The defensive points stop calculating when the first team solves the challenge.
      team => challenge.calc_defensive_points(start_time, first_solve.created_at),
      # Give the team that was first to solve the first capture bonus.
      first_solve.team => challenge.calc_first_capture_bonus(start_time, first_solve.created_at)
    }
  end

  # This takes a list of shares and the challenge first solve time and uses this information to calculate
  # how many points each team actually receives
  def calculate_offensive_points_for_solved_challenges(first_solve)
    shares = solved_challenges.map do |solved_challenge|
      [solved_challenge.team, challenge.calc_shares(first_solve.created_at, solved_challenge.created_at)]
    end.to_h

    challenge_point_value = challenge.calc_point_value(start_calculation_at, first_solve.created_at)
    convert_shares_to_points_for(shares, challenge_point_value)
  end

  def convert_shares_to_points_for(shares, challenge_point_value)
    total_shares = shares.values.sum

    shares.map do |team, num_shares|
      [team, (num_shares / total_shares) * challenge_point_value]
    end.to_h
  end
end
