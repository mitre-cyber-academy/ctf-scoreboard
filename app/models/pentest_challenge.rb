class PentestChallenge < Challenge
  belongs_to :pentest_game, inverse_of: :challenges, class_name: 'PentestGame'

  has_many :flags, inverse_of: :challenge, foreign_key: 'challenge_id', class_name: 'PentestFlag', dependent: :destroy

  has_many :solved_challenges, foreign_key: 'challenge_id', inverse_of: :challenge, class_name: 'PentestSolvedChallenge', dependent: :destroy

  accepts_nested_attributes_for :flags, allow_destroy: true

  validates :defense_period, :unsolved_increment_period, numericality: { greater_than: 0 }

  # This bypasses game open check and only looks at the challenge state
  def challenge_open?
    state.eql? 'open'
  end

  def open?
    challenge_open? && Game.instance.open?
  end

  def get_solved_challenge_for(team, flag)
    solved_challenges.find { |sc| sc.team_id.eql?(team&.id) && sc.flag_id.eql?(flag&.id) }
  end

  def can_be_solved_by(team, flag)
    get_solved_challenge_for(team, flag).nil? && !team.eql?(flag&.team)
  end

  def calc_shares(first_solve_time, current_solve_time)
    initial_shares - (((current_solve_time - first_solve_time) / solved_decrement_period.hours) * solved_decrement_shares)
  end

  def calc_point_value(start_time, first_solve_time)
    point_value + ((first_solve_time - start_time) / unsolved_increment_period.hours) * unsolved_increment_points
  end

  def calc_first_capture_bonus(start_time, end_time)
  first_capture_point_bonus + (((end_time - start_time) / unsolved_increment_period.hours) * unsolved_increment_points)
  end

  def calc_defensive_points(start_time, end_time)
    ((end_time - start_time) / defense_period.hours) * defense_points
  end
end
