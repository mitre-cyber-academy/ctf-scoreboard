# frozen_string_literal: true

class PentestChallenge < Challenge
  belongs_to :pentest_game, inverse_of: :challenges, class_name: 'PentestGame'

  has_many :flags, inverse_of: :challenge, foreign_key: 'challenge_id', class_name: 'PentestFlag', dependent: :destroy

  has_many :solved_challenges, foreign_key: 'challenge_id', inverse_of: :challenge, class_name: 'PentestSolvedChallenge', dependent: :destroy

  accepts_nested_attributes_for :flags, allow_destroy: true

  validates :defense_period, :unsolved_increment_period, numericality: { greater_than: 0 }

  def open?
    challenge_open? && Game.instance.open?
  end

  def get_solved_challenge_for(team, flag)
    solved_challenges.find { |sc| sc.team_id.eql?(team&.id) && sc.flag_id.eql?(flag&.id) }
  end

  # Teams cannot solve a challenge if they are the owner of the flag or if they have already solved it
  def can_be_solved_by(team, flag)
    get_solved_challenge_for(team, flag).nil? && !team.eql?(flag&.team)
  end

  # Calc shares calculates the share decrease between the first solve time and current time
  def calc_shares(first_solve_time, current_solve_time)
    initial_shares - (((current_solve_time - first_solve_time) / solved_decrement_period.hours) * solved_decrement_shares)
  end

  # Calc point value takes the flag start time and challenge first solve time and calculates
  # the total value of the challenge that will be divided between the solving teams
  def calc_point_value(start_time, first_solve_time)
    point_value + ((first_solve_time - start_time) / unsolved_increment_period.hours) * unsolved_increment_points
  end

  def calc_defensive_points(start_time, end_time)
    ((end_time - start_time) / defense_period.hours) * defense_points
  end
end
